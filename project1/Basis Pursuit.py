# -*- coding: utf-8 -*-
"""Untitled23.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OY7uNjL7FZPxVkW3yzyxyGKJm0nRqOVe
"""

import numpy as np
import librosa
import matplotlib.pyplot as plt
import soundfile as sf
from scipy.signal import stft, istft
from scipy.stats import pearsonr
from sklearn.metrics import mean_squared_error

# --- CVXPY 用于凸优化（Basis Pursuit） ---
import cvxpy as cp

# -----------------------------
# 1. 加载音频 & 做 STFT
# -----------------------------
audio_path = "./1-137-A-32.wav"
y, sr = librosa.load(audio_path, sr=None)

# 可选：对音频做归一化，防止数值过大或过小
y = y / np.max(np.abs(y))

# STFT 参数
nperseg = 512
f, t, Zxx = stft(y, fs=sr, nperseg=nperseg)

# 将实部和虚部分开
Zxx_real = np.real(Zxx)  # shape = (freq_bins, time_frames)
Zxx_imag = np.imag(Zxx)  # 用于后面拼回相位

freq_bins, time_frames = Zxx_real.shape
print(f"STFT shape (freq_bins, time_frames): {freq_bins}, {time_frames}")

# -----------------------------
# 2. 构造随机字典 (也可换成已学习好的字典)
# -----------------------------
n_atoms = 512  # 字典原子数
# 维度匹配：每列是一个原子 => 字典的 shape = (freq_bins, n_atoms)
D = np.random.randn(freq_bins, n_atoms).astype(np.float32)

# -----------------------------
# 3. Basis Pursuit 求解函数 (CVXPY)
# -----------------------------
def solve_basis_pursuit(D, z, exact=True, eps=1e-3):
    """
    用 CVXPY 解 Basis Pursuit:
      minimize ||x||_1
      s.t. D@x = z   (exact=True)
         or
         ||D@x - z||_2 <= eps  (exact=False)
    D: shape (freq_bins, n_atoms)
    z: shape (freq_bins,) 要拟合的目标向量
    exact: 是否严格等式约束
    eps: 如果 exact=False，则允许的残差容忍度
    返回: 稀疏解 x 的 numpy 向量 shape (n_atoms,)
    """
    n_atoms = D.shape[1]

    # 定义优化变量
    x = cp.Variable(n_atoms)

    # 定义约束
    if exact:
        constraints = [D @ x == z]
    else:
        constraints = [cp.norm2(D @ x - z) <= eps]

    # 定义目标函数
    objective = cp.Minimize(cp.norm1(x))

    # 构造问题并求解
    prob = cp.Problem(objective, constraints)
    # 选择一个适合 L1 问题的求解器，例如 'ECOS' 或 'SCS'
    # 如果 exact 约束不可行，prob.solve() 可能报错/失败。
    result = prob.solve(solver=cp.SCS, verbose=False)

    if x.value is None:
        # 说明问题不可行或没有得到解
        return None
    return x.value

# -----------------------------
# 4. 对每帧做 BP 求解稀疏系数
# -----------------------------
sparse_coeffs = np.zeros((n_atoms, time_frames), dtype=np.float32)

# 选择是否用严格等式 (exact=True) 还是带噪声余量 (exact=False)
use_exact = False  # 你可以切换到 True，看是否可行

eps = 1e-2  # 若 use_exact=False，用来控制允许的误差

for i in range(time_frames):
    z_i = Zxx_real[:, i].astype(np.float32)
    x_sol = solve_basis_pursuit(D, z_i, exact=use_exact, eps=eps)

    if x_sol is None:
        # 不可行时，这里做一些降级处理，比如把该帧系数置0
        print(f"Frame {i} is infeasible under exact constraint.")
        x_sol = np.zeros(n_atoms, dtype=np.float32)

    sparse_coeffs[:, i] = x_sol

# -----------------------------
# 5. 重构实部，再拼回虚部做 iSTFT
# -----------------------------
Zxx_reconstructed_real = D @ sparse_coeffs  # shape = (freq_bins, time_frames)
Zxx_reconstructed = Zxx_reconstructed_real + 1j * Zxx_imag

_, y_reconstructed = istft(Zxx_reconstructed, fs=sr, nperseg=nperseg)

# -----------------------------
# 6. 计算评价指标 (SNR, MSE, PCC)
# -----------------------------
def compute_metrics(original, reconstructed):
    min_len = min(len(original), len(reconstructed))
    original = original[:min_len]
    reconstructed = reconstructed[:min_len]
    noise = original - reconstructed

    snr = 10 * np.log10(np.sum(original**2) / np.sum(noise**2) + 1e-12)
    mse = mean_squared_error(original, reconstructed)
    pcc, _ = pearsonr(original, reconstructed)
    return snr, mse, pcc

snr, mse, pcc = compute_metrics(y, y_reconstructed)

# -----------------------------
# 7. 显示结果、保存音频
# -----------------------------
print(f"SNR: {snr:.2f} dB, MSE: {mse:.6f}, PCC: {pcc:.4f}")

import matplotlib.pyplot as plt
plt.figure()
plt.plot(y, label='Original')
plt.plot(y_reconstructed, '--', label='Reconstructed (BP)')
plt.legend()
plt.title(f"BP Reconstruction\nSNR={snr:.2f} dB, MSE={mse:.6f}, PCC={pcc:.4f}")
plt.show()

sf.write('reconstructed_audio_bp.wav', y_reconstructed, sr)
print("Reconstructed audio saved as 'reconstructed_audio_bp.wav'")