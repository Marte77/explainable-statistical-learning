# -*- coding: utf-8 -*-
"""sklearn-omp.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Lhl-V27IGTHmNvM6Q77Hl3oH6nO74AXx
"""

import numpy as np
import librosa
import librosa.display
import matplotlib.pyplot as plt
#from sklearn.linear_model import OrthogonalMatchingPursuit
from sklearn.linear_model import Lasso
from scipy.signal import stft, istft
import soundfile as sf

# 1. Load File
# audio_path = './1-137-A-32.wav'    # Yu Jin's test file
audio_path = './audio_for_test_sheeps.wav'
y, sr = librosa.load(audio_path,sr = None)# sr:The original sample rate of the audio file
plt.figure(figsize=(8,6), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(y, label="Original vector")

# 2. Signal pre-processingï¼šSTFT (Short-Time Fourier Transform)
f, t, Zxx = stft(y, fs=sr, nperseg=512) # nperseg: length of each segment
Zxx_real = np.real(Zxx)  # Use only real part for simplicity
Zxx_real.shape

# 3: Initialize sensing matrices
n_atoms = 1024  # Number of atoms

#generates samples from the standard normal distribution (mean = 0, variance = 1)
dictionary = np.random.randn(Zxx_real.shape[0], n_atoms) 

# 4: Apply Lasso
lasso = Lasso(alpha=0.2)
sparse_coeffs = np.zeros((n_atoms, Zxx_real.shape[1]))

# Process each frame(each line in Zxx_real) separately
for i in range(Zxx_real.shape[1]):  
    lasso.fit(dictionary, Zxx_real[:, i])
    sparse_coeffs[:, i] = lasso.coef_

# 5: Reconstruct Signal from Sparse Representation
Zxx_reconstructed = dictionary @ sparse_coeffs
_, y_reconstructed = istft(Zxx_reconstructed + 1j*np.imag(Zxx), fs=sr, nperseg=512)

plt.figure(figsize=(8,6), dpi= 100, facecolor='w', edgecolor='k')
plt.plot(y, label="Original vector")
plt.plot(y_reconstructed, '--', label="Estimated (Lasso) solution")
plt.legend()

# 6: Save and Play Processed Audio
sf.write('reconstructed_audio.wav', y_reconstructed, sr)